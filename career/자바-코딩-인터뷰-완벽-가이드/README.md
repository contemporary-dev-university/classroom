# 교재
> - [자바 코딩 인터뷰 완벽 가이드 책](http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9791157688197&orderClick=LA6)
> - [자바 코딩 인터뷰 완벽 가이드 책 원서](http://www.kyobobook.co.kr/product/detailViewEng.laf?mallGb=ENG&ejkGb=BNT&barcode=9781839212062&orderClick=JAD)


# 공부방법
> - 전체 내용중 객체지향, 빅오, 동시성, 함수형, 단위테스트, 시스템확장성의 내용 학습
> - 알고리즘의 학습은 추후 진행
> - 책에 나온 예제코드 https://github.com/dybooksIT/java-coding-interview

# 목차
[Part-2-자바-핵심-개념-이해하기](##-Part-2-자바-핵심-개념-이해하기)
  - [6장-객체지향-프로그래밍](###-6장-객체지향-프로그래밍)
    - [6.1-객체지향-프로그래밍의-개념-이해](####-6.1-객체지향-프로그래밍의-개념-이해)
    - [6.2-SOLID-원칙-이해](####-6.2-SOLID-원칙-이해)
    - [6.3-객체지향-프로그래밍,-SOLID,-GOF-디자인-패턴과-관련한-유명-질문](####-6.3-객체지향-프로그래밍,-SOLID,-GOF-디자인-패턴과-관련한-유명-질문)
    - [6.4-코딩-테스트](####-6.4-코딩-테스트)
    - [7장-알고리즘의-빅-오-분석법](###-7장-알고리즘의-빅-오-분석법)
    - [7.1-유추](####-7.1-유추)- 
    - [7.2-빅-오-시간-복잡도](####-7.2-빅-오-시간-복잡도)
    - [7.3-최고의-경우,-최악의-경우,-기대하는-경우](####-7.3-최고의-경우,-최악의-경우,-기대하는-경우)
    - [7.4-빅-오-예제](####-7.4-빅-오-예제)
    - [7.5-기술-인터뷰를-위한-꿀팁](####-7.5-기술-인터뷰를-위한-꿀팁)

[Part-4-동시성과-함수형-프로그래밍](##-Part-4-동시성과-함수형-프로그래밍)

  - [16장-동시성](###-16장-동시성)

    - [16.1-자바-동시성(멀티스레딩)의-개요](####-16.1-자바-동시성(멀티스레딩)의-개요)

    - [16.2-기술-인터뷰](####-16.2-기술-인터뷰)

  - [17장-함수형-프로그래밍](###-17장-함수형-프로그래밍)

    - [17.1-자바-함수형-프로그래밍의-개요](####-17.1-자바-함수형-프로그래밍의-개요)

    - [17.2-기술-인터뷰](####-17.2-기술-인터뷰)

  - [18장-단위-테스트](###-18장-단위-테스트)

    - [18.1-단위-테스트-개요](####-18.1-단위-테스트-개요)

    - [18.2-기술-인터뷰](####-18.2-기술-인터뷰)

  - [19장-시스템-확장성](###-19장-시스템-확장성)

    - [19.1-확장성의-개요](####-19.1-확장성의-개요)

    - [19.2-기술-인터뷰](####-19.2-기술-인터뷰)

    - [19.3-확장성에-관한-통찰력을-얻는-10가지 문제](####-19.3-확장성에-관한-통찰력을-얻는-10가지-문제)

---

# contents
> 학습내용을 아래에 정리 혹은 정리한 코드 등을 링크로 연결


## Part 1 인터뷰에서 묻는 기술 외적인 영역
### 1장 인터뷰를 준비하는 방법
### 2장 유명 IT 기업 인터뷰 살펴보기
### 3장 일반적인 기술 외 질문 및 답변 방법
### 4장 불합격에 대처하는 방법
### 5장 기술 인터뷰 접근 방법

## Part 2 자바 핵심 개념 이해하기
### 6장 객체지향 프로그래밍
#### 6.1 객체지향 프로그래밍의 개념 이해
- 6.1.1 객체란 무엇인가?
- 6.1.2 클래스란 무엇인가?
- 6.1.3 추상화란 무엇인가?
- 6.1.4 캡슐화란 무엇인가?
- 6.1.5 상속이란 무엇인가?
- 6.1.6 다형성이란 무엇인가?
- 6.1.7 연관이란 무엇인가?
- 6.1.8 집약이란 무엇인가?
- 6.1.9 구성이란 무엇인가?

#### 6.2 SOLID 원칙 이해
- 6.2.1 S란 무엇인가?
- 6.2.2 O란 무엇인가?
- 6.2.3 L이란 무엇인가?
- 6.2.4 I란 무엇인가?
- 6.2.5 D란 무엇인가?
#### 6.3 객체지향 프로그래밍, SOLID, GOF 디자인 패턴과 관련한 유명 질문
- 6.3.1 객체지향 프로그래밍에서 메서드 오버라이딩이란 무엇인가?
- 6.3.2 객체지향 프로그래밍에서 메서드 오버로딩이란 무엇인가?
- 6.3.3 자바에서 공변 메서드 오버라이딩이란 무엇인가?
- 6.3.4 오버라이딩 및 오버로딩 메서드에서 예외를 다룰 때 주요 제한 사항은 무엇인가?
6.3.5 슈퍼클래스의 오버라이드된 메서드를 서브클래스의 오버라이딩 메서드에서 어떻게 - 호출할 수 있는가?
- 6.3.6 main 메서드를 오버라이드 또는 오버로드할 수 있는가?
- 6.3.7 자바에서 static이 아닌 메서드를 static 메서드로 오버라이드할 수 있는가?
- 6.3.8 자바 인터페이스 안에 abstract가 아닌 메서드를 포함할 수 있는가?
- 6.3.9 default 메서드를 가지는 인터페이스와 추상 클래스의 주요 차이점은 무엇인가?
- 6.3.10 추상 클래스와 인터페이스의 주요 차이점은 무엇인가?
- 6.3.11 abstract 메서드가 없는 추상 클래스를 만들 수 있는가?
- 6.3.12 추상이면서 동시에 final인 클래스를 만들 수 있는가?
- 6.3.13 다형성, 오버라이딩, 오버로딩의 차이점은 무엇인가?
- 6.3.14 바인딩 작업이란 무엇인가?
- 6.3.15 정적 바인딩과 동적 바인딩의 주요 차이점은 무엇인가?
- 6.3.16 자바에서 메서드 하이딩이란 무엇인가?
- 6.3.17 자바에서 가상 메서드를 작성할 수 있는가?
- 6.3.18 추상화와 다형성의 차이점은 무엇인가?
- 6.3.19 다형성을 구현하는 방법으로 오버로딩을 고려할 수 있는가?
- 6.3.20 데커레이터 패턴에 적합한 객체지향 프로그래밍 개념은 무엇인가?
- 6.3.21 싱글턴 패턴은 언제 사용해야 하는가?
- 6.3.22 전략 패턴과 상태 패턴의 차이점은 무엇인가?
- 6.3.23 프록시 패턴과 데커레이터 패턴의 차이점은 무엇인가?
- 6.3.24 퍼사드 패턴과 데커레이터 패턴의 차이점은 무엇인가?
- 6.3.25 템플릿 메서드 패턴과 전략 패턴의 주요 차이점은 무엇인가?
- 6.3.26 빌더 패턴과 팩토리 패턴의 주요 차이점은 무엇인가?
- 6.3.27 어댑터 패턴과 브리지 패턴의 주요 차이점은 무엇인가?
#### 6.4 코딩 테스트
- 6.4.1 코딩 테스트 1: 주크박스
- 6.4.2 코딩 테스트 2: 자판기
- 6.4.3 코딩 테스트 3: 카드 한 벌
- 6.4.4 코딩 테스트 4: 주차장
- 6.4.5 코딩 테스트 5: 온라인 도서관 시스템
- 6.4.6 코딩 테스트 6: 해시 테이블
- 6.4.7 코딩 테스트 7: 파일 시스템
- 6.4.8 코딩 테스트 8: 튜플
- 6.4.9 코딩 테스트 9: 영화표 예약 시스템이 있는 영화관
- 6.4.10 코딩 테스트 10: 원형 바이트 버퍼
- 6.5 마치며

### 7장 알고리즘의 빅 오 분석법
#### 7.1 유추
#### 7.2 빅 오 시간 복잡도
#### 7.3 최고의 경우, 최악의 경우, 기대하는 경우
#### 7.4 빅 오 예제
- 7.4.1 예제 1: O(1)
- 7.4.2 예제 2: O(n) - 선형 시간 알고리즘
- 7.4.3 예제 3: O(n) - 상수 제외
- 7.4.4 예제 4: 비우세항 제외
- 7.4.5 예제 5: 입력 데이터가 다르면 변수도 다르게 설정
- 7.4.6 예제 6: 서로 다른 단계의 합 또는 곱
- 7.4.7 예제 7: logn 실행 시간
- 7.4.8 예제 8: 재귀 실행 시간
- 7.4.9 예제 9: 이진 트리의 중위 순회
- 7.4.10 예제 10: n의 변동
- 7.4.11 예제 11: 메모이제이션
- 7.4.12 예제 12: 행렬의 1/2 반복 실행
- 7.4.13 예제 13: 중첩 반복문에서 O(1) 식별
- 7.4.14 예제 14: 배열의 1/2 반복 실행
- 7.4.15 예제 15: 빅 오 표현식 줄이기
- 7.4.16 예제 16: O(logn)의 시간 복잡도를 가지는 반복 실행
- 7.4.17 예제 17: 문자열 비교
- 7.4.18 예제 18: 팩토리얼의 빅 오
- 7.4.19 예제 19: n 표기법을 사용할 때 주의 사항
- 7.4.20 예제 20: 합과 반복 횟수
- 7.4.21 예제 21: 빅 오의 반복 횟수
- 7.4.22 예제 22: 자릿수
- 7.4.23 예제 23: 정렬
#### 7.5 기술 인터뷰를 위한 꿀팁
#### 7.6 마치며

#### 8장 재귀 및 동적 프로그래밍
- 8.1 재귀의 개요
- 8.1.1 재귀 문제 인식하기
- 8.2 동적 프로그래밍의 개요
- 8.2.1 메모이제이션
- 8.2.2 태뷸레이션
- 8.3 코딩 테스트
- 8.3.1 코딩 테스트 1: 로봇 격자 지도
- 8.3.2 코딩 테스트 2: 하노이의 탑
- 8.3.3 코딩 테스트 3: 요세푸스
- 8.3.4 코딩 테스트 4: 영역 구하기
- 8.3.5 코딩 테스트 5: 동전 거스름돈
- 8.3.6 코딩 테스트 6: 5개의 탑
- 8.3.7 코딩 테스트 7: 마법의 인덱스
- 8.3.8 코딩 테스트 8: 떨어지는 공
- 8.3.9 코딩 테스트 9: 상자 쌓기
- 8.3.10 코딩 테스트 10: 문자열 순열
- 8.3.11 코딩 테스트 11: 기사의 여행
- 8.3.12 코딩 테스트 12: 중괄호 여닫기
- 8.3.13 코딩 테스트 13: 계단
- 8.3.14 코딩 테스트 14: 부분 집합 합계
- 8.3.15 코딩 테스트 15: 줄바꿈
- 8.4 마치며

#### 9장 비트 조작
- 9.1 비트 연산 개요
- 9.1.1 자바 int형의 이진 표기법
- 9.1.2 비트 연산자
- 9.1.3 비트 시프트 연산자
- 9.1.4 비트를 다루는 요령
- 9.2 코딩 테스트
- 9.2.1 코딩 테스트 1: 비트값 가져오기
- 9.2.2 코딩 테스트 2: 비트값 설정하기
- 9.2.3 코딩 테스트 3: 비트값 초기화하기
- 9.2.4 코딩 테스트 4: 손으로 이진수 더하기
- 9.2.5 코딩 테스트 5: 코드로 이진수 더하기
- 9.2.6 코딩 테스트 6: 손으로 이진수 곱하기
- 9.2.7 코딩 테스트 7: 코드로 이진수 곱하기
- 9.2.8 코딩 테스트 8: 손으로 이진수 빼기
- 9.2.9 코딩 테스트 9: 코드로 이진수 빼기
- 9.2.10 코딩 테스트 10: 손으로 이진수 나누기
- 9.2.11 코딩 테스트 11: 코드로 이진수 나누기
- 9.2.12 코딩 테스트 12: 비트 치환하기
- 9.2.13 코딩 테스트 13: 가장 길게 연속된 1
- 9.2.14 코딩 테스트 14: 다음과 이전 숫자
- 9.2.15 코딩 테스트 15: 변환
- 9.2.16 코딩 테스트 16: 식 최대화하기
- 9.2.17 코딩 테스트 17: 홀수와 짝수 비트 교체하기
- 9.2.18 코딩 테스트 18: 비트 회전
- 9.2.19 코딩 테스트 19: 숫자 계산하기
- 9.2.20 코딩 테스트 20: 고유한 요소
- 9.2.21 코딩 테스트 21: 중복값 검색하기
- 9.2.22 코딩 테스트 22: 고유 요소 2개
- 9.2.23 코딩 테스트 23: 멱집합
- 9.2.24 코딩 테스트 24: 유일하게 설정된 비트의 위치 검색하기
- 9.2.25 코딩 테스트 25: 부동소수점을 이진수 혹은 반대로 변환하기
- 9.3 마치며
- 
### Part 3 알고리즘과 자료구조
#### 10장 배열과 문자열
- 10.1 배열과 문자열의 개요
- 10.2 코딩 테스트
- 10.2.1 코딩 테스트 1: 고유 문자 ①
- 10.2.2 코딩 테스트 2: 고유 문자 ②
- 10.2.3 코딩 테스트 3: 문자열 인코딩
- 10.2.4 코딩 테스트 4: 동일한 문자열 만들기
- 10.2.5 코딩 테스트 5: 문자열 요약하기
- 10.2.6 코딩 테스트 6: 정수 추출하기
- 10.2.7 코딩 테스트 7: 서러게이트 페어에서 코드 포인트 추출하기
- 10.2.8 코딩 테스트 8: 회전하는 문자열
- 10.2.9 코딩 테스트 9: 행렬의 90도 회전
- 10.2.10 코딩 테스트 10: 0을 포함하는 행렬
- 10.2.11 코딩 테스트 11: 배열 하나로 스택 3개 구현하기
- 10.2.12 코딩 테스트 12: 쌍
- 10.2.13 코딩 테스트 13: 정렬된 배열 병합
- 10.2.14 코딩 테스트 14: 중앙값
- 10.2.15 코딩 테스트 15: 모든 요소가 1인 부분 행렬
- 10.2.16 코딩 테스트 16: 물이 가장 많은 용기
- 10.2.17 코딩 테스트 17: 원형 정렬 배열에서 검색
- 10.2.18 코딩 테스트 18: 구간 병합
- 10.2.19 코딩 테스트 19: 주유소 순환 방문
- 10.2.20 코딩 테스트 20: 빗물 모으기
- 10.2.21 코딩 테스트 21: 주식 거래
- 10.2.22 코딩 테스트 22: 가장 긴 시퀀스
- 10.2.23 코딩 테스트 23: 게임 점수 계산
- 10.2.24 코딩 테스트 24: 중복 검사
- 10.2.25 코딩 테스트 25: 가장 긴 고유 하위 문자열
- 10.2.26 코딩 테스트 26: 요소를 순위로 변환
- 10.2.27 코딩 테스트 27: 모든 부분 배열의 고유 요소
- 10.2.28 코딩 테스트 28: 배열 k번 회전
- 10.2.29 코딩 테스트 29: 정렬된 배열의 고유한 절댓값
- 10.3 마치며
- 
#### 11장 연결 리스트와 맵
- 11.1 연결 리스트의 개요
- 11.2 맵의 개요
- 11.3 코딩 테스트
- 11.3.1 코딩 테스트 1: 맵에 값을 삽입, 검색, 삭제하기
- 11.3.2 코딩 테스트 2: 키 집합과 값 매핑
- 11.3.3 코딩 테스트 3: 너트와 볼트
- 11.3.4 코딩 테스트 4: 중복 노드 제거
- 11.3.5 코딩 테스트 5: 연결 리스트 재배열
- 11.3.6 코딩 테스트 6: 뒤에서 n번째 노드
- 11.3.7 코딩 테스트 7: 고리의 시작 노드 감지
- 11.3.8 코딩 테스트 8: 회문
- 11.3.9 코딩 테스트 9: 연결 리스트 2개의 합
- 11.3.10 코딩 테스트 10: 교차 연결 리스트
- 11.3.11 코딩 테스트 11: 인접 노드 교체
- 11.3.12 코딩 테스트 12: 정렬된 연결 리스트 2개 병합
- 11.3.13 코딩 테스트 13: 중복 경로 제거
- 11.3.14 코딩 테스트 14: 마지막 노드를 머리 노드로 만들기
- 11.3.15 코딩 테스트 15: 단일 연결 리스트 노드를 k개 단위로 반전시키기
- 11.3.16 코딩 테스트 16: 이중 연결 리스트 반전시키기
- 11.3.17 코딩 테스트 17: LRU 캐시
- 11.4 마치며

#### 12장 스택과 큐
- 12.1 스택의 개요
- 12.2 큐의 개요
- 12.3 코딩 테스트
- 12.3.1 코딩 테스트 1: 문자열 뒤집기
- 12.3.2 코딩 테스트 2: 중괄호 스택
- 12.3.3 코딩 테스트 3: 접시 스택
- 12.3.4 코딩 테스트 4: 주가 스팬
- 12.3.5 코딩 테스트 5: 최솟값 스택
- 12.3.6 코딩 테스트 6: 스택으로 만든 큐
- 12.3.7 코딩 테스트 7: 큐로 만든 스택
- 12.3.8 코딩 테스트 8: 히스토그램 최대 영역
- 12.3.9 코딩 테스트 9: 가장 작은 숫자
- 12.3.10 코딩 테스트 10: 섬
- 12.3.11 코딩 테스트 11: 최단 경로
- 12.4 전위, 후위, 중위 표현식
- 12.5 마치며

#### 13장 트리와 그래프
- 13.1 트리의 개요
- 13.1.1 기본 트리
- 13.1.2 이진 탐색 트리
- 13.1.3 균형 및 불균형 이진 트리
- 13.1.4 완전 이진 트리
- 13.1.5 정 이진 트리
- 13.1.6 포화 이진 트리
- 13.1.7 이진 힙
- 13.2 그래프의 개요
- 13.2.1 인접 행렬
- 13.2.2 인접 리스트
- 13.2.3 그래프 순회 방법
- 13.3 코딩 테스트
- 13.3.1 코딩 테스트 1: 두 노드 사이의 경로
- 13.3.2 코딩 테스트 2: 정렬된 배열로 최소 이진 탐색 트리 만들기
- 13.3.3 코딩 테스트 3: 레벨별 리스트
- 13.3.4 코딩 테스트 4: 하위 트리
- 13.3.5 코딩 테스트 5: 착륙 예약 시스템
- 13.3.6 코딩 테스트 6: 균형 이진 트리
- 13.3.7 코딩 테스트 7: 이진 트리가 이진 탐색 트리일 때
- 13.3.8 코딩 테스트 8: 후속 노드
- 13.3.9 코딩 테스트 9: 위상 정렬
- 13.3.10 코딩 테스트 10: 공통 조상
- 13.3.11 코딩 테스트 11: 체스 기사
- 13.3.12 코딩 테스트 12: 이진 트리의 양 끝 노드 출력
- 13.3.13 코딩 테스트 13: 최대 경로 합계
- 13.3.14 코딩 테스트 14: 대각선 순회
- 13.3.15 코딩 테스트 15: 이진 탐색 트리의 중복 처리
- 13.3.16 코딩 테스트 16: 이진 트리의 동형화
- 13.3.17 코딩 테스트 17: 이진 트리의 오른쪽 면
- 13.3.18 코딩 테스트 18: k번째로 큰 요소
- 13.3.19 코딩 테스트 19: 이진 트리 좌우 반전
- 13.3.20 코딩 테스트 20: 이진 트리의 나선형 레벨 순회
- 13.3.21 코딩 테스트 21: 단말 노드에서 k만큼 떨어진 노드
- 13.3.22 코딩 테스트 22: 주어진 합계를 만족하는 쌍
- 13.3.23 코딩 테스트 23: 이진 트리의 수직 합
- 13.3.24 코딩 테스트 24: 최대 힙을 최소 힙으로 변환
- 13.3.25 코딩 테스트 25: 이진 트리의 대칭
- 13.3.26 코딩 테스트 26: 최소 비용으로 n개의 밧줄 연결하기
- 13.4 한 걸음 더 나아가기
- 13.5 마치며

#### 14장 정렬과 검색
- 14.1 정렬 알고리즘
- 14.1.1 힙 정렬
- 14.1.2 병합 정렬
- 14.1.3 퀵 정렬
- 14.1.4 버킷 정렬
- 14.1.5 기수 정렬
- 14.2 검색 알고리즘
- 14.3 코딩 테스트
- 14.3.1 코딩 테스트 1: 정렬된 배열 2개 병합하기
- 14.3.2 코딩 테스트 2: 애너그램 함께 묶기
- 14.3.3 코딩 테스트 3: 크기를 알 수 없는 리스트
- 14.3.4 코딩 테스트 4: 연결 리스트 병합 정렬
- 14.3.5 코딩 테스트 5: 빈 문자열 사이에 흩어진 문자열
- 14.3.6 코딩 테스트 6: 추가 큐를 사용하여 큐 정렬
- 14.3.7 코딩 테스트 7: 추가 공간 없이 큐 정렬
- 14.3.8 코딩 테스트 8: 추가 스택을 사용하여 스택 정렬
- 14.3.9 코딩 테스트 9: 제자리에서 스택 정렬
- 14.3.10 코딩 테스트 10: 완전 정렬 행렬에서 검색
- 14.3.11 코딩 테스트 11: 정렬된 행렬에서 검색
- 14.3.12 코딩 테스트 12: 첫 번째 1의 위치
- 14.3.13 코딩 테스트 13: 두 요소 사이의 차이
- 14.3.14 코딩 테스트 14: 스트림 순위
- 14.3.15 코딩 테스트 15: 봉우리와 계곡
- 14.3.16 코딩 테스트 16: 왼쪽에서 가장 가까운 작은 숫자
- 14.3.17 코딩 테스트 17: 단어 찾기
- 14.3.18 코딩 테스트 18: 주어진 배열 기반으로 배열 재정렬
- 14.4 마치며

#### 15장 수학과 퍼즐
- 15.1 수학과 퍼즐 문제를 푸는 요령
- 15.2 코딩 테스트
- 15.2.1 코딩 테스트 1: FizzBuzz
- 15.2.2 코딩 테스트 2: 로마 숫자
- 15.2.3 코딩 테스트 3:개의 문 여닫기
- 15.2.4 코딩 테스트 4: 8개의 팀
- 15.2.5 코딩 테스트 5: 소인수가 3, 5, 7뿐인 숫자 목록에서 k번째 수 찾기
- 15.2.6 코딩 테스트 6: 숫자 시퀀스 디코딩 개수
- 15.2.7 코딩 테스트 7: ABCD
- 15.2.8 코딩 테스트 8: 겹치는 직사각형
- 15.2.9 코딩 테스트 9: 큰 수 곱하기
- 15.2.10 코딩 테스트 10: 동일한 자릿수 구성을 가진 다음으로 큰 수
- 15.2.11 코딩 테스트 11: 자릿수로 나누어지는 수
- 15.2.12 코딩 테스트 12: 초콜릿 쪼개기
- 15.2.13 코딩 테스트 13: 시계 각도
- 15.2.14 코딩 테스트 14: 피타고라스 삼조
- 15.2.15 코딩 테스트 15: 엘리베이터 스케줄링
- 15.3 마치며

## Part 4 동시성과 함수형 프로그래밍
### 16장 동시성
#### 16.1 자바 동시성(멀티스레딩)의 개요
#### 16.2 기술 인터뷰
- 16.2.1 기술 인터뷰 1: 스레드 생명 주기 상태
- 16.2.2 기술 인터뷰 2: 교착 상태
- 16.2.3 기술 인터뷰 3: 경쟁 상태
- 16.2.4 기술 인터뷰 4: 재진입 가능한 록
- 16.2.5 기술 인터뷰 5: Executor와 ExecutorService
- 16.2.6 기술 인터뷰 6: Runnable과 Callable
- 16.2.7 기술 인터뷰 7: 기아 상태
- 16.2.8 기술 인터뷰 8: 라이브 록
- 16.2.9 기술 인터뷰 9: start와 run 메서드
- 16.2.10 기술 인터뷰 10: Thread와 Runnable
- 16.2.11 기술 인터뷰 11: CountDownLatch와 CyclicBarrier
- 16.2.12 기술 인터뷰 12: wait와 sleep
- 16.2.13 기술 인터뷰 13: ConcurrentHashMap과 Hashtable
- 16.2.14 기술 인터뷰 14: ThreadLocal
- 16.2.15 기술 인터뷰 15: submit과 execute
- 16.2.16 기술 인터뷰 16: interrupted와 isInterrupted
- 16.2.17 기술 인터뷰 17: 스레드 중단
- 16.2.18 기술 인터뷰 18: 스레드 사이의 데이터 공유
- 16.2.19 기술 인터뷰 19: ReadWriteLock
- 16.2.20 기술 인터뷰 20: 생산자-소비자
#### 16.3 마치며

### 17장 함수형 프로그래밍
#### 17.1 자바 함수형 프로그래밍의 개요
- 17.1.1 함수형 프로그래밍의 핵심 개념
#### 17.2 기술 인터뷰
- 17.2.1 기술 인터뷰 1: 람다식 구성
- 17.2.2 기술 인터뷰 2: 함수형 인터페이스
- 17.2.3 기술 인터뷰 3: 컬렉션과 스트림
- 17.2.4 기술 인터뷰 4: map 함수
- 17.2.5 기술 인터뷰 5: flatMap 함수
- 17.2.6 기술 인터뷰 6: map과 flatMap 함수의 차이점
- 17.2.7 기술 인터뷰 7: filter 함수
- 17.2.8 기술 인터뷰 8: 중간 연산과 종료 연산
- 17.2.9 기술 인터뷰 9: peek 함수
- 17.2.10 기술 인터뷰 10: 지연 스트림
- 17.2.11 기술 인터뷰 11: 함수형 인터페이스와 일반 인터페이스
- 17.2.12 기술 인터뷰 12: Supplier와 Consumer 인터페이스
- 17.2.13 기술 인터뷰 13: Predicate 인터페이스
- 17.2.14 기술 인터뷰 14: findFirst와 findAny 메서드
- 17.2.15 기술 인터뷰 15: 배열을 스트림으로 변환
- 17.2.16 기술 인터뷰 16: 병렬 스트림
- 17.2.17 기술 인터뷰 17: 메서드 참조
- 17.2.18 기술 인터뷰 18: default 메서드
- 17.2.19 기술 인터뷰 19: Iterator와 Spliterator 인터페이스
- 17.2.20 기술 인터뷰 20: Optional
- 17.2.21 기술 인터뷰 21: String::valueOf
#### 17.3 마치며

### 18장 단위 테스트
#### 18.1 단위 테스트 개요
#### 18.2 기술 인터뷰
- 18.2.1 기술 인터뷰 1: AAA
- 18.2.2 기술 인터뷰 2: FIRST
- 18.2.3 기술 인터뷰 3: 테스트 픽스처
- 18.2.4 기술 인터뷰 4: 예외 테스트
- 18.2.5 기술 인터뷰 5: 개발자 또는 테스터
- 18.2.6 기술 인터뷰 6: 제이유닛 확장 기능
- 18.2.7 기술 인터뷰 7: @Before* 및 @After* 애너테이션
- 18.2.8 기술 인터뷰 8: 모킹과 스텁
- 18.2.9 기술 인터뷰 9: 테스트 스위트
- 18.2.10 기술 인터뷰 10: 테스트 메서드 무시
- 18.2.11 기술 인터뷰 11: 가정문
- 18.2.12 기술 인터뷰 12: @Rule
- 18.2.13 기술 인터뷰 13: 테스트 메서드의 반환형
- 18.2.14 기술 인터뷰 14: 동적 테스트
- 18.2.15 기술 인터뷰 15: 중첩 테스트
#### 18.3 마치며

### 19장 시스템 확장성
#### 19.1 확장성의 개요
#### 19.2 기술 인터뷰
- 19.2.1 기술 인터뷰 1: 확장 유형
- 19.2.2 기술 인터뷰 2: 고가용성
- 19.2.3 기술 인터뷰 3: 짧은 지연시간
- 19.2.4 기술 인터뷰 4: 클러스터링
- 19.2.5 기술 인터뷰 5: 지연시간, 대역폭, 처리량
- 19.2.6 기술 인터뷰 6: 부하분산
- 19.2.7 기술 인터뷰 7: 고정 세션
- 19.2.8 기술 인터뷰 8: 샤딩
- 19.2.9 기술 인터뷰 9: 비공유 아키텍처
- 19.2.10 기술 인터뷰 10: 장애 극복 기능
- 19.2.11 기술 인터뷰 11: 세션 복제
- 19.2.12 기술 인터뷰 12: CAP 정리
- 19.2.13 기술 인터뷰 13: 소셜 네트워크
#### 19.3 확장성에 관한 통찰력을 얻는 10가지 문제
- 19.3.1 URL 단축 서비스 설계
- 19.3.2 글로벌 동영상 스트리밍 서비스 설계
- 19.3.3 글로벌 채팅 서비스 설계
- 19.3.4 게시판 서비스 및 소셜 네트워크 설계
- 19.3.5 글로벌 파일 저장 및 공유 서비스 설계
- 19.3.6 초대형 소셜 미디어 서비스 설계
- 19.3.7 차량 공유 서비스 설계
- 19.3.8 검색 엔진 관련 서비스 설계
- 19.3.9 API 비율 제한기 설계
- 19.3.10 주변 검색 서비스 설계
- 19.3.11 정리
#### 19.4 마치며